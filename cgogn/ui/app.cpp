/*******************************************************************************
 * CGoGN                                                                        *
 * Copyright (C), IGG Group, ICube, University of Strasbourg, France            *
 *                                                                              *
 * This library is free software; you can redistribute it and/or modify it      *
 * under the terms of the GNU Lesser General Public License as published by the *
 * Free Software Foundation; either version 2.1 of the License, or (at your     *
 * option) any later version.                                                   *
 *                                                                              *
 * This library is distributed in the hope that it will be useful, but WITHOUT  *
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        *
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License  *
 * for more details.                                                            *
 *                                                                              *
 * You should have received a copy of the GNU Lesser General Public License     *
 * along with this library; if not, write to the Free Software Foundation,      *
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.           *
 *                                                                              *
 * Web site: http://cgogn.unistra.fr/                                           *
 * Contact information: cgogn@unistra.fr                                        *
 *                                                                              *
 *******************************************************************************/

#include <cgogn/ui/app.h>
#include <cgogn/ui/view.h>

#include <GL/gl3w.h>
#include <GLFW/glfw3.h>

#include <imgui/imgui_internal.h>

#include "bgfx-imgui/imgui_impl_bgfx.h"
#include <bx/timer.h>
#include <bx/rng.h>

#include <map>
#include <thread>
#include <math.h>
#include <filesystem>

namespace cgogn
{

namespace ui
{



	const uint32_t kDimWidth = 11;
const uint32_t kDimHeight = 11;



float64 App::frame_time_ = 0;
bx::RngMwc m_mwc;
uint32_t m_debug;
uint32_t m_reset;
bgfx::DynamicVertexBufferHandle m_vbh[kDimWidth * kDimHeight];
bgfx::DynamicIndexBufferHandle m_ibh;
bgfx::ProgramHandle m_program;
int64_t m_timeOffset;

	struct PosColorVertex
{
	float m_x;
	float m_y;
	float m_z;
	uint32_t m_abgr;

	static void init()
	{
		ms_layout.begin()
			.add(bgfx::Attrib::Position, 3, bgfx::AttribType::Float)
			.add(bgfx::Attrib::Color0, 4, bgfx::AttribType::Uint8, true)
			.end();
	};

	static bgfx::VertexLayout ms_layout;
};

bgfx::VertexLayout PosColorVertex::ms_layout;

static PosColorVertex s_cubeVertices[] = {
	{-1.0f, 1.0f, 1.0f, 0xff000000},   {1.0f, 1.0f, 1.0f, 0xff0000ff},	 {-1.0f, -1.0f, 1.0f, 0xff00ff00},
	{1.0f, -1.0f, 1.0f, 0xff00ffff},   {-1.0f, 1.0f, -1.0f, 0xffff0000}, {1.0f, 1.0f, -1.0f, 0xffff00ff},
	{-1.0f, -1.0f, -1.0f, 0xffffff00}, {1.0f, -1.0f, -1.0f, 0xffffffff},
};

static const uint16_t s_cubeTriList[] = {
	0, 1, 2,		  // 0
	1, 3, 2, 4, 6, 5, // 2
	5, 6, 7, 0, 2, 4, // 4
	4, 2, 6, 1, 5, 3, // 6
	5, 7, 3, 0, 4, 1, // 8
	4, 5, 1, 2, 3, 6, // 10
	6, 3, 7,
};

static const uint16_t s_cubeTriStrip[] = {
	0, 1, 2, 3, 7, 1, 5, 0, 4, 2, 6, 7, 4, 5,
};

static void glfw_error_callback(int error, const char* description)
{
	std::cerr << "Glfw Error " << error << ": " << description << std::endl;
}

#ifdef CGOGN_GL43_DEBUG_MODE
template <bool NOTIF>
static void APIENTRY cgogn_gl_debug_msg(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length,
										const GLchar* message, const void*)
{
	unused_parameters(id, length); // id not revelant

	if (!NOTIF && severity == GL_DEBUG_SEVERITY_NOTIFICATION)
		return;

	static std::map<GLenum, std::string> gl_dbg_str = {
		{GL_DEBUG_SOURCE_API, "Calls to the OpenGL API"},
		{GL_DEBUG_SOURCE_WINDOW_SYSTEM, "Calls to a window-system API"},
		{GL_DEBUG_SOURCE_SHADER_COMPILER, "A compiler for a shading language"},
		{GL_DEBUG_SOURCE_THIRD_PARTY, "An application associated with OpenGL"},
		{GL_DEBUG_SOURCE_APPLICATION, "Generated by the user of this application"},
		{GL_DEBUG_SOURCE_OTHER, "Other source"},
		{GL_DEBUG_TYPE_ERROR, "ERROR"},
		{GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR, "DEPRECATED_BEHAVIOR"},
		{GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, "UNDEFINED_BEHAVIOR"},
		{GL_DEBUG_TYPE_PORTABILITY, "PORTABILITY"},
		{GL_DEBUG_TYPE_PERFORMANCE, "PERFORMANCE"},
		{GL_DEBUG_TYPE_MARKER, "MAKER"},
		{GL_DEBUG_TYPE_PUSH_GROUP, "PUSH_GROUP"},
		{GL_DEBUG_TYPE_POP_GROUP, "POP_GROUP"},
		{GL_DEBUG_TYPE_OTHER, "OTHER_ERROR"}};

	switch (severity)
	{
	case GL_DEBUG_SEVERITY_HIGH:
		std::cerr << "\033[91m";
		break;
	case GL_DEBUG_SEVERITY_MEDIUM:
		std::cerr << "\033[93m";
		break;
	case GL_DEBUG_SEVERITY_LOW:
		std::cerr << "\033[95m";
		break;
	case GL_DEBUG_SEVERITY_NOTIFICATION:
		std::cerr << "\033[92m";
		break;
	}

	std::cerr << "================== DEBUG OPENGL ==========================" << std::endl;
	std::cerr << gl_dbg_str[source] << std::endl;
	std::cerr << gl_dbg_str[type] << std::endl;
	std::cerr << message << std::endl;
	std::cerr << "==========================================================" << std::endl;
	std::cerr << "\033[m" << std::endl;

	assert(severity != GL_DEBUG_SEVERITY_HIGH);
}

inline void enable_gl43_debug_mode(bool show_notif = false)
{
	glEnable(GL_DEBUG_OUTPUT);
	glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
	if (show_notif)
		glDebugMessageCallback(cgogn_gl_debug_msg<true>, nullptr);
	else
		glDebugMessageCallback(cgogn_gl_debug_msg<false>, nullptr);
}
#endif

float64 App::fps_ = 0.0;

App::App()
	: window_(nullptr), context_(nullptr), window_name_("CGoGN"), window_width_(512), window_height_(512),
	  framebuffer_width_(0), framebuffer_height_(0), background_color_(0.35f, 0.35f, 0.35f, 1.0f),
	  interface_scaling_(1.0f), mouse_scroll_speed_(50.0f), show_imgui_(true), show_demo_(false), current_view_(nullptr)
{
#ifdef WIN32
	{
		bool ok = false;
		// Set output mode to handle virtual terminal sequences
		HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
		if (hOut != INVALID_HANDLE_VALUE)
		{
			DWORD dwMode = 0;
			if (GetConsoleMode(hOut, &dwMode))
			{
				dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
				if (SetConsoleMode(hOut, dwMode))
					ok = true;
			}
		}
		if (ok)
		{
			// std::cout << "Windows \033[41m\033[37m console \033[42m color \033[42m mode " << std::endl;
			// std::cout << "\033[40m \033[91m YEEHHH \033[92m YEEHHH \033[93m YEEHHH \033[96m YEEHHH \033[95m YEEHHH "
			// 		  << "\033[m" << std::endl;
		}
	}
#endif
	// std::cout << "Windows \033[41m\033[37m console \033[42m color \033[42m mode " << std::endl;
	// std::cout << "\033[40m \033[91m YEEHHH \033[92m YEEHHH \033[93m YEEHHH \033[96m YEEHHH \033[95m YEEHHH "
	// 		  << "\033[m" << std::endl;


	tlq_ = boost::synapse::create_thread_local_queue();

	glfwSetErrorCallback(glfw_error_callback);
	if (!glfwInit())
		std::cerr << "Failed to initialize GFLW!" << std::endl;

	/*
	// GL 3.3 + GLSL 150 + Core Profile
	const char* glsl_version = "#version 150";
#ifdef CGOGN_GL43_DEBUG_MODE
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
#else
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
#endif
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	//glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
	*/

	window_ = glfwCreateWindow(window_width_, window_height_, window_name_.c_str(), nullptr, nullptr);
	if (window_ == nullptr)
	{
		std::cerr << "Failed to create Window!" << std::endl;
		glfwTerminate();
	}

	glfwMakeContextCurrent(window_);
	glfwSwapInterval(1); // Enable vsync

	//bool err = gl3wInit() != 0;
	//if (err)
	//	std::cerr << "Failed to initialize OpenGL loader!" << std::endl;

	
	
	// BGFX init
	// Initialize BGFX
    bgfx::Init bgfx_init;
    bgfx_init.type = bgfx::RendererType::OpenGL;


    // Platform specific data
#if BX_PLATFORM_LINUX || BX_PLATFORM_BSD
	bgfx_init.platformData.ndt = glfwGetX11Display();
	bgfx_init.platformData.nwh = (void*)(uintptr_t)glfwGetX11Window(window_);
#elif BX_PLATFORM_OSX
	init.platformData.nwh = glfwGetCocoaWindow(window_);
#elif BX_PLATFORM_WINDOWS
	bgfx_init.platformData.nwh = glfwGetWin32Window(window_);
#endif

	int width, height;
	glfwGetWindowSize(window_, &width, &height);
	bgfx_init.resolution.width = (uint32_t)width;
	bgfx_init.resolution.height = (uint32_t)height;
	bgfx_init.resolution.reset = BGFX_RESET_VSYNC;

	if (!bgfx::init(bgfx_init))
		std::cerr << "Failed to initialize BGFX!" << std::endl;
	
	// Set view 0 clear state.
	bgfx::setViewClear(0, BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH, 0x303030ff, 1.0f, 0);
	bgfx::setViewRect(0, 0, 0, width, height);


	IMGUI_CHECKVERSION();
	context_ = ImGui::CreateContext();

	ImGui_Implbgfx_Init(255);
	ImGui_ImplGlfw_InitForOther(window_, true);
	
	
	ImGuiIO& io = ImGui::GetIO();
	(void)io;
	io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
	io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;	  // Enable Docking
	io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;	  // Enable Multi-Viewport / Platform Windows
	// io.ConfigDockingWithShift = false;
	// io.ConfigWindowsResizeFromEdges = true;

	ImGui::StyleColorsDark();


	ImGuiStyle& style = ImGui::GetStyle();
	style.WindowRounding = 0.0f;
	style.Colors[ImGuiCol_WindowBg].w = 0.75f;

	std::string fontpath = std::string(CGOGN_STR(CGOGN_DATA_PATH)) + std::string("fonts/Roboto-Medium.ttf");
	/*ImFont* font = */ io.Fonts->AddFontFromFileTTF(fontpath.c_str(), 14);
	
	glfwSetWindowUserPointer(window_, this);
	// This creates a segmentation fault with bgfx
	/*
	std::cout << glGetString(GL_VENDOR) << std::endl;
	std::cout << glGetString(GL_RENDERER) << std::endl;
	std::cout << glGetString(GL_VERSION) << std::endl;
	*/


	glfwSetWindowSizeCallback(window_, [](GLFWwindow* wi, int width, int height) {
		App* that = static_cast<App*>(glfwGetWindowUserPointer(wi));

		that->window_width_ = width;
		that->window_height_ = height;
		glfwGetFramebufferSize(wi, &(that->framebuffer_width_), &(that->framebuffer_height_));

		// Resize BGFX
		bgfx::reset(width, height, BGFX_RESET_VSYNC);
		bgfx::setViewRect(0, 0, 0, width, height);


		for (const auto& v : that->views_)
			v->resize_event(that->window_width_, that->window_height_, that->framebuffer_width_,
							that->framebuffer_height_);
	});
	/*
	glfwSetMouseButtonCallback(window_, [](GLFWwindow* wi, int b, int a, int m) {
		App* that = static_cast<App*>(glfwGetWindowUserPointer(wi));

		if (ImGui::GetIO().WantCaptureMouse || ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
		{
			that->inputs_.mouse_buttons_ = 0;
			return;
		}

		if (that->current_view_)
		{
			that->inputs_.shift_pressed_ = (m & GLFW_MOD_SHIFT);
			that->inputs_.control_pressed_ = (m & GLFW_MOD_CONTROL);
			that->inputs_.alt_pressed_ = (m & GLFW_MOD_ALT);
			that->inputs_.meta_pressed_ = (m & GLFW_MOD_SUPER);

			double now = glfwGetTime();

			switch (a)
			{
			case GLFW_PRESS:
				that->inputs_.mouse_buttons_ |= 1 << b;
				that->current_view_->mouse_press_event(b, that->inputs_.previous_mouse_x_,
													   that->inputs_.previous_mouse_y_);
				if (now - that->inputs_.previous_click_time_ < that->inputs_.double_click_timeout_)
					that->current_view_->mouse_dbl_click_event(b, that->inputs_.previous_mouse_x_,
															   that->inputs_.previous_mouse_y_);
				that->inputs_.previous_click_time_ = now;
				break;
			case GLFW_RELEASE:
				that->inputs_.mouse_buttons_ &= ~(1 << b);
				that->current_view_->mouse_release_event(b, that->inputs_.previous_mouse_x_,
														 that->inputs_.previous_mouse_y_);
				break;
			}
		}
	});

	glfwSetCursorPosCallback(window_, [](GLFWwindow* wi, double cx, double cy) {
		App* that = static_cast<App*>(glfwGetWindowUserPointer(wi));

		if (ImGui::GetIO().WantCaptureMouse || ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
		{
			that->inputs_.mouse_buttons_ = 0;
			return;
		}

		ImGui::GetIO().MousePos = ImVec2(float(cx), float(cy));

		int32 px = int32(std::floor(cx));
		int32 py = int32(std::floor(cy));

		for (const auto& v : that->views_)
		{
			if (v->contains(px, that->window_height_ - py))
			{
				if (v.get() != that->current_view_)
				{
					that->inputs_.mouse_buttons_ = 0;
					that->current_view_ = v.get();
				}

				v->mouse_move_event(px, py);
			}
		}

		that->inputs_.previous_mouse_x_ = px;
		that->inputs_.previous_mouse_y_ = py;
	});

	glfwSetScrollCallback(window_, [](GLFWwindow* wi, double dx, double dy) {
		App* that = static_cast<App*>(glfwGetWindowUserPointer(wi));

		if (ImGui::GetIO().WantCaptureMouse || ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow))
		{
			that->inputs_.mouse_buttons_ = 0;
			return;
		}

		if (that->current_view_)
			that->current_view_->mouse_wheel_event(dx, that->mouse_scroll_speed_ * dy);
	});

	glfwSetCursorEnterCallback(window_, [](GLFWwindow* wi, int enter) {
		App* that = static_cast<App*>(glfwGetWindowUserPointer(wi));

		if (ImGui::GetIO().WantCaptureMouse || ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
		{
			that->inputs_.mouse_buttons_ = 0;
			return;
		}

		if (!enter)
		{
			that->inputs_.mouse_buttons_ = 0;
			that->current_view_ = nullptr;
		}
	});
	*/

	glfwSetKeyCallback(window_, [](GLFWwindow* wi, int k, int s, int a, int m) {
		unused_parameters(s);
		App* that = static_cast<App*>(glfwGetWindowUserPointer(wi));

		that->inputs_.shift_pressed_ = (m & GLFW_MOD_SHIFT);
		that->inputs_.control_pressed_ = (m & GLFW_MOD_CONTROL);
		that->inputs_.alt_pressed_ = (m & GLFW_MOD_ALT);
		that->inputs_.meta_pressed_ = (m & GLFW_MOD_SUPER);

		if (k == GLFW_KEY_ESCAPE)
		{
			that->stop();
			return;
		}

		switch (a)
		{
		case GLFW_PRESS:
			if (k == GLFW_KEY_SPACE && that->inputs_.control_pressed_)
				that->show_imgui_ = !that->show_imgui_;
			if (k == GLFW_KEY_H && that->inputs_.control_pressed_)
				that->show_demo_ = !that->show_demo_;
			else if (k == GLFW_KEY_KP_ADD && that->inputs_.control_pressed_)
			{
				that->interface_scaling_ += 0.1f;
				ImGui::GetIO().FontGlobalScale = that->interface_scaling_;
			}
			else if (k == GLFW_KEY_KP_SUBTRACT && that->inputs_.control_pressed_)
			{
				that->interface_scaling_ -= 0.1f;
				ImGui::GetIO().FontGlobalScale = that->interface_scaling_;
			}
			break;
		case GLFW_RELEASE:
			break;
		}

		if (that->current_view_)
		{
			switch (a)
			{
			case GLFW_PRESS:
				if ((k == GLFW_KEY_F) && that->inputs_.control_pressed_ && !that->inputs_.shift_pressed_)
				{
					GLFWmonitor* monitor = glfwGetPrimaryMonitor();
					const GLFWvidmode* mode = glfwGetVideoMode(monitor);
					glfwSetWindowMonitor(wi, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
					glfwSetInputMode(wi, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
					return;
				}
				if ((k == GLFW_KEY_F) && that->inputs_.control_pressed_ && that->inputs_.shift_pressed_)
				{
					int count;
					GLFWmonitor** monitors = glfwGetMonitors(&count);
					if (count > 1)
					{
						const GLFWvidmode* mode = glfwGetVideoMode(monitors[1]);
						glfwSetWindowMonitor(wi, monitors[1], 0, 0, mode->width, mode->height, mode->refreshRate);
						glfwSetInputMode(wi, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
					}
					else
						std::cerr << "Only one monitor" << std::endl;
					return;
				}
				if ((k == GLFW_KEY_W) && that->inputs_.control_pressed_)
				{
					glfwSetWindowMonitor(wi, nullptr, 100, 100, 1024, 1024, 0);
					glfwSetInputMode(wi, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
					return;
				}
				if ((k == GLFW_KEY_S) && that->inputs_.control_pressed_)
				{
					that->current_view_->save_screenshot();
					return;
				}
				that->current_view_->key_press_event(k);
				break;
			case GLFW_RELEASE:
				that->current_view_->key_release_event(k);
				break;
			}
		}
	});
	
	


	current_view_ = add_view();
}

App::~App()
{
}

void App::set_window_size(int32 w, int32 h)
{
	glfwSetWindowSize(window_, w, h);
}

void App::set_window_title(const std::string& name)
{
	window_name_ = name;
	if (window_)
		glfwSetWindowTitle(window_, window_name_.c_str());
}

View* App::add_view()
{
	// TODO : Implement this for bgfx
	return nullptr;

	if (uint32(views_.size()) < 4)
	{
		glfwMakeContextCurrent(window_);
		views_.push_back(std::make_unique<View>(&inputs_, "view" + std::to_string(uint32(views_.size()))));
		adapt_views_geometry();
		return views_.back().get();
	}
	return nullptr;
}

Module* App::module(const std::string& name) const
{
	auto it = std::find_if(modules_.begin(), modules_.end(), [&](Module* m) { return m->name().compare(name) == 0; });
	if (it != modules_.end())
		return *it;
	return nullptr;
}

void App::close_event()
{
	for (const auto& v : views_)
		v->close_event();

	cgogn::rendering::ShaderProgram::clean_all();
}

void App::adapt_views_geometry()
{
	switch (uint32(views_.size()))
	{
	case 1:
		views_[0]->set_view_ratio(0, 0, 1, 1);
		break;
	case 2:
		views_[0]->set_view_ratio(0, 0, 0.5, 1);
		views_[1]->set_view_ratio(0.5, 0, 0.5, 1);
		break;
	case 3:
		views_[0]->set_view_ratio(0, 0, 0.5, 0.5);
		views_[1]->set_view_ratio(0.5, 0, 0.5, 0.5);
		views_[2]->set_view_ratio(0, 0, 1, 0.5);
		break;
	case 4:
		views_[0]->set_view_ratio(0, 0, 0.5, 0.5);
		views_[1]->set_view_ratio(0.5, 0, 0.5, 0.5);
		views_[2]->set_view_ratio(0, 0.5, 0.5, 0.5);
		views_[3]->set_view_ratio(0.5, 0.5, 0.5, 0.5);
		break;
	}

	for (const auto& v : views_)
		v->resize_event(window_width_, window_height_, framebuffer_width_, framebuffer_height_);
}

void App::init_modules()
{
	for (Module* m : modules_)
		m->init();
}


const bgfx::Memory* load_file(std::string _filePath, std::string parent = "")
{
    // Using iostream and fstream
	namespace fs = std::filesystem;
	fs::path current_path = fs::current_path();
	while (!current_path.empty() && current_path.filename() != "bin")
	{
		current_path = current_path.parent_path();
	}

	fs::path file_path(current_path);
	

	_filePath = "shaders/" + (parent == "" ? _filePath : parent + "/" + _filePath);
	_filePath = file_path.string() + "/" + _filePath;

    // Open file
    std::ifstream file(_filePath, std::ios::in | std::ios::binary | std::ios::ate);

    // Check if file is open
    if (!file.is_open())
    {
        std::cerr << "Failed to open file: " << _filePath << std::endl;
        return nullptr;
    }

    // Get file size
    std::streampos size = file.tellg();
    // Allocate memory
    const bgfx::Memory* mem = bgfx::alloc((uint32_t)size + 1);
    // Read file
    file.seekg(0, std::ios::beg);
    file.read((char*)mem->data, size);
    // Close file
    file.close();

    // Add null terminator
    ((char*)mem->data)[size] = '\0';

    return mem;
}




int App::launch()
{
	

	bgfx::setViewClear(0, BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH, 0x303030ff, 1.0f, 0);

	// Create vertex stream declaration.
	PosColorVertex::init();

	// Create static vertex buffer.
	for (uint32_t yy = 0; yy < kDimHeight; ++yy)
	{
		for (uint32_t xx = 0; xx < kDimWidth; ++xx)
		{
			m_vbh[yy * kDimWidth + xx] = bgfx::createDynamicVertexBuffer(
				// Static data can be passed with bgfx::makeRef
				bgfx::makeRef(s_cubeVertices, sizeof(s_cubeVertices)), PosColorVertex::ms_layout);
		}
	}

	// Create static index buffer.
	m_ibh = bgfx::createDynamicIndexBuffer(
		// Static data can be passed with bgfx::makeRef
	bgfx::makeRef(s_cubeTriStrip, sizeof(s_cubeTriStrip)));

	// Create program from shaders.

	m_timeOffset = bx::getHPCounter();

	bgfx::ShaderHandle vertex_handler = bgfx::createShader(load_file("vs_cubes.bin", "dynamic"));
	bgfx::ShaderHandle fragment_shader = bgfx::createShader(load_file("fs_cubes.bin", "dynamic"));

	bgfx::ProgramHandle test_program = bgfx::createProgram(vertex_handler, fragment_shader, true);

	// Uniforms
    bgfx::UniformHandle u_transform = bgfx::createUniform("u_transform", bgfx::UniformType::Mat4);
    bgfx::UniformHandle u_color = bgfx::createUniform("u_color", bgfx::UniformType::Vec4);

	

	int32 frame_counter = 0;
	while (!glfwWindowShouldClose(window_))
	{
		boost::synapse::poll(*tlq_);

		glfwPollEvents();

		frame_time_ = glfwGetTime();
		if (++frame_counter == 50)
		{
			double now = frame_time_;
			frame_counter = 0;
			fps_ = 50 / (now - time_last_50_frames_);
			time_last_50_frames_ = now;
		}

		

		// 3D Rendering here
		
		
		
		

		
		// 3D Rendering

		int m_height, m_width;
		glfwGetWindowSize(window_, &m_width, &m_height);

		// Set view and projection matrix for view 0.
		float time = (float)((bx::getHPCounter() - m_timeOffset) / double(bx::getHPFrequency()));

		const bx::Vec3 at = {0.0f, 0.0f, 0.0f};
		const bx::Vec3 eye = {0.0f, 0.0f, -35.0f};

		// Set view and projection matrix for view 0.
		{
			float view[16];
			bx::mtxLookAt(view, eye, at);

			float proj[16];
			bx::mtxProj(proj, 60.0f, float(m_width) / float(m_height), 0.1f, 100.0f, bgfx::getCaps()->homogeneousDepth);
			bgfx::setViewTransform(0, view, proj);

			// Set view 0 default viewport.
			bgfx::setViewRect(0, 0, 0, uint16_t(m_width), uint16_t(m_height));
		}

		// This dummy draw call is here to make sure that view 0 is cleared
		// if no other draw calls are submitted to view 0.
		bgfx::touch(0);

		{
			float angle = bx::frnd(&m_mwc);
			float mtx[16];
			bx::mtxRotateZ(mtx, angle);

			const bgfx::Memory* mem = bgfx::copy(s_cubeVertices, sizeof(s_cubeVertices));
			PosColorVertex* vertex = (PosColorVertex*)mem->data;
			const uint32_t abgr = m_mwc.gen();
			for (uint32_t ii = 0; ii < BX_COUNTOF(s_cubeVertices); ++ii)
			{
				bx::store(&vertex[ii].m_x, bx::mul(bx::load<bx::Vec3>(&s_cubeVertices[ii].m_x), mtx));
				vertex[ii].m_abgr = abgr;
			}

			uint32_t idx = m_mwc.gen() % (kDimWidth * kDimHeight);
			bgfx::update(m_vbh[idx], 0, mem);
		}

		// Submit 11x11 cubes.
		for (uint32_t yy = 0; yy < kDimHeight; ++yy)
		{
			for (uint32_t xx = 0; xx < kDimWidth; ++xx)
			{
				float mtx[16];
				bx::mtxRotateXY(mtx, time + xx * 0.21f, time + yy * 0.37f);
				mtx[12] = -15.0f + float(xx) * 3.0f;
				mtx[13] = -15.0f + float(yy) * 3.0f;
				mtx[14] = 0.0f;

				// Set model matrix for rendering.
				bgfx::setTransform(mtx);

				// Set vertex and index buffer.
				bgfx::setVertexBuffer(0, m_vbh[yy * kDimWidth + xx]);
				bgfx::setIndexBuffer(m_ibh);

				// Set render states.
				bgfx::setState(0 | BGFX_STATE_DEFAULT | BGFX_STATE_PT_TRISTRIP);

				// Submit primitive for rendering to view 0.
				bgfx::submit(0, test_program);
			}
		}

		// Advance to next frame. Rendering thread will be kicked to
		// process submitted rendering primitives.
		bgfx::frame();		

		// Interface update
		if (show_imgui_)
		{

			ImGui::SetCurrentContext(context_);

			ImGui_Implbgfx_NewFrame();
			ImGui_ImplGlfw_NewFrame();
			
		
			ImGui::NewFrame();

			
			ImGuiViewport* viewport = ImGui::GetMainViewport();
			ImGui::SetNextWindowPos(viewport->Pos);
			ImGui::SetNextWindowSize(viewport->Size);
			ImGui::SetNextWindowViewport(viewport->ID);
			

			ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
			ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
			ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));

			ImGuiWindowFlags window_flags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;
			window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize |
							ImGuiWindowFlags_NoMove;
			window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
			window_flags |= ImGuiWindowFlags_NoBackground;

			ImGui::Begin("DockSpaceWindow", nullptr, window_flags);

			ImGui::PopStyleVar(3);
			

			if (show_demo_)
				ImGui::ShowDemoWindow();

			if (ImGui::BeginMainMenuBar())
			{
				if (ImGui::BeginMenu("Main menu"))
				{
					if (ImGui::BeginMenu("Preferences"))
					{
						if (ImGui::ColorEdit3("Background color", background_color_.data(),
											  ImGuiColorEditFlags_NoInputs))
						{
							for (const auto& v : views_)
								v->request_update();
						}
						ImGui::InputFloat("Scroll speed", &mouse_scroll_speed_, 0.1f, 1.0f);
						if (ImGui::InputFloat("Interface scale", &interface_scaling_, 0.1f, 1.0f))
							ImGui::GetIO().FontGlobalScale = interface_scaling_;
						ImGui::EndMenu();
					}
					if (ImGui::BeginMenu("Views"))
					{
						for (const auto& v : views_)
						{
							if (ImGui::BeginMenu(v->name().c_str()))
							{
								if (ImGui::MenuItem("Save camera"))
									v->save_camera();
								if (ImGui::MenuItem("Restore camera"))
									v->restore_camera();
								if (ImGui::Button("Show entire scene"))
									v->show_entire_scene();
								// ImGui::Checkbox("Lock view BB", &v->scene_bb_locked_);
								ImGui::EndMenu();
							}
						}
						ImGui::EndMenu();
					}
					ImGui::Separator();
					if (ImGui::MenuItem("Quit", "[ESC]"))
						this->stop();
					ImGui::EndMenu();
				}
				for (Module* m : modules_)
				{
					ImGui::PushID(m->name().c_str());
					m->main_menu();
					ImGui::PopID();
				}
				ImGui::EndMainMenuBar();
			}

			ImGuiID dockspace_id = ImGui::GetID("DockSpaceWindow");
			ImGuiDockNodeFlags dockspace_flags =
				ImGuiDockNodeFlags_PassthruCentralNode | ImGuiDockNodeFlags_NoDockingInCentralNode;
			ImGui::DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags);
			dockspace_flags |= ImGuiDockNodeFlags_DockSpace;

			ImGuiID dockIdLeft = 0;
			ImGuiID dockIdBottom = 0;
			static bool first_render = true;

			if (first_render)
			{
				ImGui::DockBuilderRemoveNode(dockspace_id);
				ImGui::DockBuilderAddNode(dockspace_id, dockspace_flags);
				ImGui::DockBuilderSetNodeSize(dockspace_id, viewport->Size);

				dockIdLeft = ImGui::DockBuilderSplitNode(dockspace_id, ImGuiDir_Left, 0.22f, nullptr, &dockspace_id);
				dockIdBottom = ImGui::DockBuilderSplitNode(dockspace_id, ImGuiDir_Down, 0.15f, nullptr, &dockspace_id);

				ImGui::DockBuilderFinish(dockspace_id);
			}

			ImGui::Begin("Modules", nullptr, ImGuiWindowFlags_NoSavedSettings);
			ImGui::SetWindowSize({0, 0});
			for (Module* m : modules_)
			{
				ImGui::PushID(m->name().c_str());
				ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(255, 128, 0, 200));
				ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(255, 128, 0, 255));
				ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(255, 128, 0, 128));
				if (ImGui::CollapsingHeader(m->name().c_str()))
				{
					ImGui::PopStyleColor(3);
					m->left_panel();
				}
				else
					ImGui::PopStyleColor(3);
				ImGui::PopID();
			}
			ImGui::End();

			for (Module* m : modules_)
			{
				ImGui::PushID(m->name().c_str());
				m->popups();
				ImGui::PopID();
			}

			if (first_render)
				ImGui::DockBuilderDockWindow("Modules", dockIdLeft);

			ImGui::End();
			

			first_render = false;
			

			ImGui::Render();

			ImGui_Implbgfx_RenderDrawLists(ImGui::GetDrawData());

		

			// Update and Render additional Platform Windows
			ImGui::UpdatePlatformWindows();
			ImGui::RenderPlatformWindowsDefault();
			glfwMakeContextCurrent(window_);
			
		}

		// Swap buffers
		glfwSwapBuffers(window_);
		// Render frame
       // bgfx::frame();

		

        

		/*

		//glClearColor(background_color_[0], background_color_[1], background_color_[2], background_color_[3]);
		//glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		for (const auto& v : views_)
		{
			v->draw();
			if (uint32(views_.size()) > 1)
			{
				if (v.get() == current_view_)
					param_frame_->color_ = rendering::GLColor(0.25f, 0.75f, 0.25f, 1);
				else
					param_frame_->color_ = rendering::GLColor(0.25f, 0.25f, 0.25f, 1);
				param_frame_->w_ = float(v->viewport_width());
				param_frame_->h_ = float(v->viewport_height());
				param_frame_->draw();
			}
		}

		if (show_imgui_)
		{
			ImGui::SetCurrentContext(context_);
			ImGui_ImplOpenGL3_NewFrame();
			ImGui_ImplGlfw_NewFrame();
			ImGui::NewFrame();

			ImGuiViewport* viewport = ImGui::GetMainViewport();
			ImGui::SetNextWindowPos(viewport->Pos);
			ImGui::SetNextWindowSize(viewport->Size);
			ImGui::SetNextWindowViewport(viewport->ID);

			ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
			ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
			ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));

			ImGuiWindowFlags window_flags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;
			window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize |
							ImGuiWindowFlags_NoMove;
			window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
			window_flags |= ImGuiWindowFlags_NoBackground;

			ImGui::Begin("DockSpaceWindow", nullptr, window_flags);

			ImGui::PopStyleVar(3);

			if (show_demo_)
				ImGui::ShowDemoWindow();

			if (ImGui::BeginMainMenuBar())
			{
				if (ImGui::BeginMenu("Main menu"))
				{
					if (ImGui::BeginMenu("Preferences"))
					{
						if (ImGui::ColorEdit3("Background color", background_color_.data(),
											  ImGuiColorEditFlags_NoInputs))
						{
							for (const auto& v : views_)
								v->request_update();
						}
						ImGui::InputFloat("Scroll speed", &mouse_scroll_speed_, 0.1f, 1.0f);
						if (ImGui::InputFloat("Interface scale", &interface_scaling_, 0.1f, 1.0f))
							ImGui::GetIO().FontGlobalScale = interface_scaling_;
						ImGui::EndMenu();
					}
					if (ImGui::BeginMenu("Views"))
					{
						for (const auto& v : views_)
						{
							if (ImGui::BeginMenu(v->name().c_str()))
							{
								if (ImGui::MenuItem("Save camera"))
									v->save_camera();
								if (ImGui::MenuItem("Restore camera"))
									v->restore_camera();
								if (ImGui::Button("Show entire scene"))
									v->show_entire_scene();
								// ImGui::Checkbox("Lock view BB", &v->scene_bb_locked_);
								ImGui::EndMenu();
							}
						}
						ImGui::EndMenu();
					}
					ImGui::Separator();
					if (ImGui::MenuItem("Quit", "[ESC]"))
						this->stop();
					ImGui::EndMenu();
				}
				for (Module* m : modules_)
				{
					ImGui::PushID(m->name().c_str());
					m->main_menu();
					ImGui::PopID();
				}
				ImGui::EndMainMenuBar();
			}

			ImGuiID dockspace_id = ImGui::GetID("DockSpaceWindow");
			ImGuiDockNodeFlags dockspace_flags =
				ImGuiDockNodeFlags_PassthruCentralNode | ImGuiDockNodeFlags_NoDockingInCentralNode;
			ImGui::DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags);
			dockspace_flags |= ImGuiDockNodeFlags_DockSpace;

			ImGuiID dockIdLeft = 0;
			ImGuiID dockIdBottom = 0;
			static bool first_render = true;

			if (first_render)
			{
				ImGui::DockBuilderRemoveNode(dockspace_id);
				ImGui::DockBuilderAddNode(dockspace_id, dockspace_flags);
				ImGui::DockBuilderSetNodeSize(dockspace_id, viewport->Size);

				dockIdLeft = ImGui::DockBuilderSplitNode(dockspace_id, ImGuiDir_Left, 0.22f, nullptr, &dockspace_id);
				dockIdBottom = ImGui::DockBuilderSplitNode(dockspace_id, ImGuiDir_Down, 0.15f, nullptr, &dockspace_id);

				ImGui::DockBuilderFinish(dockspace_id);
			}

			ImGui::Begin("Modules", nullptr, ImGuiWindowFlags_NoSavedSettings);
			ImGui::SetWindowSize({0, 0});
			for (Module* m : modules_)
			{
				ImGui::PushID(m->name().c_str());
				ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(255, 128, 0, 200));
				ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(255, 128, 0, 255));
				ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(255, 128, 0, 128));
				if (ImGui::CollapsingHeader(m->name().c_str()))
				{
					ImGui::PopStyleColor(3);
					m->left_panel();
				}
				else
					ImGui::PopStyleColor(3);
				ImGui::PopID();
			}
			ImGui::End();

			for (Module* m : modules_)
			{
				ImGui::PushID(m->name().c_str());
				m->popups();
				ImGui::PopID();
			}

			if (first_render)
				ImGui::DockBuilderDockWindow("Modules", dockIdLeft);

			ImGui::End();

			first_render = false;

			ImGui::Render();
			ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

			// Update and Render additional Platform Windows
			ImGui::UpdatePlatformWindows();
			ImGui::RenderPlatformWindowsDefault();
			glfwMakeContextCurrent(window_);
		}
		*/
	}

	//ImGui_ImplOpenGL3_Shutdown();
	ImGui_ImplGlfw_Shutdown();
	ImGui_Implbgfx_Shutdown();
	ImGui::DestroyContext();

	glfwDestroyWindow(window_);
	glfwTerminate();
	return EXIT_SUCCESS;
}

void App::stop()
{
	close_event();
	glfwSetWindowShouldClose(window_, GLFW_TRUE);
}

} // namespace ui

} // namespace cgogn
